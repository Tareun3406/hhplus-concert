## 동시성 제어가 필요한 부분과 해결 방법
### 콘서트 좌석 예약 API
#### 요구사항
- 같은 좌석에 대한 예약 요청이 동시에 일어날 가능성이 매우 높다.
- 이미 예약된 좌석은 추가로 예약할 수 없다.
- 한번만 예약에 성공하면 이후의 요청은 순서와 관계없이 모두 실패해야한다.
- 한번의 예약에 여러개의 좌석이 있을 수 있다. 그 중 하나라도 예약되어 있을 경우 예약에 실패한다.

#### 선택한 방법과 이유 (Redis 분산 락)
동시에 매우 많은 요청이 올것으로 예상되는 API 입니다.
많은 수의 요청을 DB 락을 통해 사용할 경우 락을 대기하는 동안 DB 의 커넥션 풀을 점유하게 됩니다.
커넥션 풀의 경우 모든 API 에서 공유 하기 때문에 서비스의 전체적인 성능에 영향을 줄수 있습니다.
배타적 락 대신 낙관적 락을 사용할 경우 커넥션 풀의 점유시간을 줄일 수 는 있으나
동시요청 개수많큼 남은 커넥션 풀을 모두 점유할 수 있는 점은 동일합니다.

따라서 락을 관리하는 주체를 DB가 아닌 외부에 위임함으로써 같은 자원에 대한 접근은 하나의 커넥션만 존재할 수 있도록 처리하는 것이 좋습니다.
동시에 들어온 요청에 대해서는 처음 한번만 성공하면 되기 때문에 순서를 고려할 필요는 없다 생각하여 레디스 분산락을 적용해 보았습니다.

### 잔액 충전 / 예약 결제 API
#### 요구사항
- 동시 요청 가능성이 적다.
- 같은 자원에 접근할 경우 순서에 관계없이 모두 성공하도록 한다.
  - 실패하는 방법도 좋지만 유효한 요청이라면 성공하는게 더 일관성있는 작업이라는 생각이 들었습니다.
- 이미 결제된 예약에 대한 추가 결제는 실패한다. (도메인 로직으로 처리 가능)

#### 선택한 방법과 이유 (DB - 비관적 락)
같은 자원을 사용하는 충전 혹은 결제 요청의 주체는 한 사람입니다.
동시성 문제가 발생할 가능성이 적기 때문에 Redis 연결 - DB 연결 의 플로우로 비즈니스가 진행될 경우 
대부분의 요청이 Redis 락에 대한 대기 없이 DB 연결까지 바로 들어갈 수 있을 것입니다.
락 획득에 어려움이 없다면 Redis 를 중간에 경유하면서 생기는 네트워크 지연이 더 크다는 생각이 들었기 때문에 DB 락을 유지하였습니다.

DB 락에는 낙관적 락과 비관적 락이 있습니다.
충돌 가능성이 적을 경우 낙관적 락이 락을 요청하는 로직이 없기 때문에 성능상 이점이 있으나,
낙관적 락의 경우 version 을 체크하기 위한 컬럼을 추가해야하고
충돌 발생시의 로직을 별도로 구성해야하는 부분이 있어 코드가 장황해진다는 생각이 들었습니다.

구체적인 성능의 차이를 아직 확인하지는 못했지만 락 대기가 없는 시점에서
비관적 락과 낙관적 락의 성능차이가 그렇게 많이 차이나지는 않을거라 생각하여 비관적 락을 사용하였습니다.
